"use strict";const OFFLINE_DATA_FILE="offline.js",CACHE_NAME_PREFIX="c2offline",BROADCASTCHANNEL_NAME="offline",CONSOLE_PREFIX="[SW] ",LAZYLOAD_KEYNAME="",broadcastChannel="undefined"==typeof BroadcastChannel?null:new BroadcastChannel("offline");function PostBroadcastMessage(e){broadcastChannel&&setTimeout(()=>broadcastChannel.postMessage(e),3e3)}function Broadcast(e){PostBroadcastMessage({type:e})}function BroadcastDownloadingUpdate(e){PostBroadcastMessage({type:"downloading-update",version:e})}function BroadcastUpdateReady(e){PostBroadcastMessage({type:"update-ready",version:e})}function IsUrlInLazyLoadList(e,t){if(!t)return!1;try{for(let a of t)if(RegExp(a).test(e))return!0}catch(r){console.error(CONSOLE_PREFIX+"Error matching in lazy-load list: ",r)}return!1}function WriteLazyLoadListToStorage(e){return"undefined"==typeof localforage?Promise.resolve():localforage.setItem("",e)}function ReadLazyLoadListFromStorage(){return"undefined"==typeof localforage?Promise.resolve([]):localforage.getItem("")}function GetCacheBaseName(){return"c2offline-"+self.registration.scope}function GetCacheVersionName(e){return GetCacheBaseName()+"-v"+e}async function GetAvailableCacheNames(){let e=await caches.keys(),t=GetCacheBaseName();return e.filter(e=>e.startsWith(t))}async function IsUpdatePending(){let e=await GetAvailableCacheNames();return e.length>=2}async function GetMainPageUrl(){let e=await clients.matchAll({includeUncontrolled:!0,type:"window"});for(let t of e){let a=t.url;if(a.startsWith(self.registration.scope)&&(a=a.substring(self.registration.scope.length)),a&&"/"!==a)return a.startsWith("?")&&(a="/"+a),a}return""}function fetchWithBypass(e,t){if("string"==typeof e&&(e=new Request(e)),!t)return fetch(e);{let a=new URL(e.url);return a.search+=Math.floor(1e6*Math.random()),fetch(a,{headers:e.headers,mode:e.mode,credentials:e.credentials,redirect:e.redirect,cache:"no-store"})}}async function CreateCacheFromFileList(e,t,a){let r=await Promise.all(t.map(e=>fetchWithBypass(e,a))),n=!0;for(let i of r)i.ok||(n=!1,console.error(CONSOLE_PREFIX+"Error fetching '"+i.url+"' ("+i.status+" "+i.statusText+")"));if(!n)throw Error("not all resources were fetched successfully");let o=await caches.open(e);try{return await Promise.all(r.map((e,a)=>o.put(t[a],e)))}catch(s){throw console.error(CONSOLE_PREFIX+"Error writing cache entries: ",s),caches.delete(e),s}}async function UpdateCheck(e){try{let t=await fetchWithBypass(OFFLINE_DATA_FILE,!0);if(!t.ok)throw Error(OFFLINE_DATA_FILE+" responded with "+t.status+" "+t.statusText);let a=await t.json(),r=a.version,n=a.fileList,i=a.lazyLoad,o=GetCacheVersionName(r),s=await caches.has(o);if(s){let l=await IsUpdatePending();l?(console.log(CONSOLE_PREFIX+"Update pending"),Broadcast("update-pending")):(console.log(CONSOLE_PREFIX+"Up to date"),Broadcast("up-to-date"));return}let c=await GetMainPageUrl();n.unshift("./"),c&&-1===n.indexOf(c)&&n.unshift(c),console.log(CONSOLE_PREFIX+"Caching "+n.length+" files for offline use"),e?Broadcast("downloading"):BroadcastDownloadingUpdate(r),i&&await WriteLazyLoadListToStorage(i),await CreateCacheFromFileList(o,n,!e);let d=await IsUpdatePending();d?(console.log(CONSOLE_PREFIX+"All resources saved, update ready"),BroadcastUpdateReady(r)):(console.log(CONSOLE_PREFIX+"All resources saved, offline support ready"),Broadcast("offline-ready"))}catch(u){console.warn(CONSOLE_PREFIX+"Update check failed: ",u)}}async function GetCacheNameToUse(e,t){if(1===e.length||!t)return e[0];let a=await clients.matchAll();if(a.length>1)return e[0];let r=e[e.length-1];return console.log(CONSOLE_PREFIX+"Updating to new version"),await Promise.all(e.slice(0,-1).map(e=>caches.delete(e))),r}async function HandleFetch(e,t){let a=await GetAvailableCacheNames();if(!a.length)return fetch(e.request);let r=await GetCacheNameToUse(a,t),n=await caches.open(r),i=await n.match(e.request);if(i)return i;let o=await Promise.all([fetch(e.request),ReadLazyLoadListFromStorage()]),s=o[0],l=o[1];if(IsUrlInLazyLoadList(e.request.url,l))try{await n.put(e.request,s.clone())}catch(c){console.warn(CONSOLE_PREFIX+"Error caching '"+e.request.url+"': ",c)}return s}self.addEventListener("install",e=>{e.waitUntil(UpdateCheck(!0).catch(()=>null))}),self.addEventListener("fetch",e=>{if(new URL(e.request.url).origin!==location.origin)return;let t="navigate"===e.request.mode,a=HandleFetch(e,t);t&&e.waitUntil(a.then(()=>UpdateCheck(!1))),e.respondWith(a)});